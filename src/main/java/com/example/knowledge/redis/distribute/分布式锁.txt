https://blog.csdn.net/xlgen157387/article/details/79036337
在分析分布式锁的三种实现方式之前，先了解一下分布式锁应该具备哪些条件：
    1、在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行；
    2、高可用的获取锁与释放锁；
    3、高性能的获取锁与释放锁；
    4、具备可重入特性；
    5、具备锁失效机制，防止死锁；
    6、具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。
分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）,
最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。

    为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：
    1、互斥性。在任意时刻，只有一个客户端能持有锁。
    2、不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。
    3、具有容错性。只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。
    4、解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。

一、基于数据库实现分布式锁(数据库乐观锁)；
    基于数据库的实现方式的核心思想是：在数据库中创建一个表，表中包含方法名等字段，并在方法名字段上创建唯一索引，
    想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。
二、基于缓存（Redis等）实现分布式锁；
    （1）获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。
    （2）获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。
    （3）释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。
三、基于Zookeeper实现分布式锁；
     (1）创建一个目录mylock；
    （2）线程A想获取锁就在mylock目录下创建临时顺序节点；
    （3）获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；
    （4）线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；
    （5）线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。
这里推荐一个Apache的开源库Curator，它是一个ZooKeeper客户端，
Curator提供的InterProcessMutex是分布式锁的实现，acquire方法用于获取锁，release方法用于释放锁。
优点：具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。
缺点：因为需要频繁的创建和删除节点，性能上不如Redis方式。
